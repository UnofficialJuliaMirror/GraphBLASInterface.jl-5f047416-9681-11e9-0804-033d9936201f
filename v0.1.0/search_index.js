var documenterSearchIndex = {"docs":
[{"location":"#GraphBLASInterface.jl-1","page":"Home","title":"GraphBLASInterface.jl","text":"","category":"section"},{"location":"context_methods/#Context-methods-1","page":"Context methods","title":"Context methods","text":"","category":"section"},{"location":"context_methods/#","page":"Context methods","title":"Context methods","text":"GrB_init\nGrB_finalize","category":"page"},{"location":"context_methods/#GraphBLASInterface.GrB_init","page":"Context methods","title":"GraphBLASInterface.GrB_init","text":"GrB_init(mode)\n\nGrB_init must called before any other GraphBLAS operation. GrB_init defines the mode that GraphBLAS will use: blocking or non-blocking. With blocking mode, all operations finish before returning to the user application. With non-blocking mode, operations can be left pending, and are computed only when needed.\n\n\n\n\n\n","category":"function"},{"location":"context_methods/#GraphBLASInterface.GrB_finalize","page":"Context methods","title":"GraphBLASInterface.GrB_finalize","text":"GrB_finalize()\n\nGrB_finalize must be called as the last GraphBLAS operation. GrB_finalize does not call GrB_wait; any pending computations are abandoned.\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#","page":"Basic matrix & vector methods","title":"Basic matrix & vector methods","text":"has_offset_indices\nzero","category":"page"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.has_offset_indices","page":"Basic matrix & vector methods","title":"GraphBLASInterface.has_offset_indices","text":"has_offset_indices(A)\n\nReturn true if indices of a GraphBLAS matrix/vector start at 0 instead of 1.\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#Base.zero","page":"Basic matrix & vector methods","title":"Base.zero","text":"zero(A)\n\nReturn an empty GraphBLAS matrix/vector with zero rows & columns and same type as A.\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#Matrix-functions-1","page":"Basic matrix & vector methods","title":"Matrix functions","text":"","category":"section"},{"location":"matrix_and_vector_methods/#","page":"Basic matrix & vector methods","title":"Basic matrix & vector methods","text":"GrB_Matrix\nGrB_Matrix_new\nGrB_Matrix_build\nGrB_Matrix_nrows\nGrB_Matrix_ncols\nGrB_Matrix_nvals\nGrB_Matrix_setElement\nGrB_Matrix_extractElement\nGrB_Matrix_extractTuples\nGrB_Matrix_dup\nGrB_Matrix_clear","category":"page"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Matrix","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Matrix","text":"GrB_Matrix(varargs...)\n\nCreate a new NULL GraphBLAS matrix.\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Matrix_new","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Matrix_new","text":"GrB_Matrix_new(A, type, nrows, ncols)\n\nInitialize a matrix with specified domain and dimensions.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Matrix_build","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Matrix_build","text":"GrB_Matrix_build(C, I, J, X, nvals, dup)\n\nStore elements from tuples into a matrix.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [1, 2, 2, 2, 3]; J = [1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Matrix_fprint(MAT, GxB_COMPLETE)\n\nGraphBLAS matrix: MAT\nnrows: 4 ncols: 4 max # entries: 5\nformat: standard CSR vlen: 4 nvec_nonempty: 3 nvec: 4 plen: 4 vdim: 4\nhyper_ratio 0.0625\nGraphBLAS type:  int8_t size: 1\nnumber of entries: 5\nrow: 1 : 1 entries [0:0]\n    column 1: int8 2\nrow: 2 : 3 entries [1:3]\n    column 1: int8 4\n    column 2: int8 3\n    column 3: int8 5\nrow: 3 : 1 entries [4:4]\n    column 3: int8 6\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Matrix_nrows","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Matrix_nrows","text":"GrB_Matrix_nrows(A)\n\nReturn the number of rows in a matrix if successful. Else return GrB_Info error code.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_nrows(MAT)\n4\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Matrix_ncols","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Matrix_ncols","text":"GrB_Matrix_ncols(A)\n\nReturn the number of columns in a matrix if successful. Else return GrB_Info error code.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_ncols(MAT)\n4\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Matrix_nvals","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Matrix_nvals","text":"GrB_Matrix_nvals(A)\n\nReturn the number of stored elements in a matrix if successful. Else return GrB_Info error code..\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [1, 2, 2, 2, 3]; J = [1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_nvals(MAT)\n5\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Matrix_setElement","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Matrix_setElement","text":"GrB_Matrix_setElement(C, X, I, J)\n\nSet one element of a matrix to a given value, C[I][J] = X.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [1, 2, 2, 2, 3]; J = [1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;\n\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractElement(MAT, 1, 1)\n2\n\njulia> GrB_Matrix_setElement(MAT, Int8(7), 1, 1)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractElement(MAT, 1, 1)\n7\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Matrix_extractElement","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Matrix_extractElement","text":"GrB_Matrix_extractElement(A, row_index, col_index)\n\nReturn element of a matrix at a given index (A[rowindex][colindex]) if successful. Else return GrB_Info error code.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [1, 2, 2, 2, 3]; J = [1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractElement(MAT, 1, 1)\n2\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Matrix_extractTuples","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Matrix_extractTuples","text":"GrB_Matrix_extractTuples(A)\n\nReturn tuples stored in a matrix if successful. Else return GrB_Info error code.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [1, 2, 2, 2, 3]; J = [1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractTuples(MAT)\n([1, 2, 2, 2, 3], [1, 1, 2, 3, 3], Int8[2, 4, 3, 5, 6])\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Matrix_dup","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Matrix_dup","text":"GrB_Matrix_dup(C, A)\n\nInitialize a new matrix with the same domain, dimensions, and contents as another matrix.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [1, 2, 2, 2, 3]; J = [1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> B = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_dup(B, MAT)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Matrix_fprint(B, GxB_SHORT)\n\nGraphBLAS matrix: B\nnrows: 4 ncols: 4 max # entries: 5\nformat: standard CSR vlen: 4 nvec_nonempty: 3 nvec: 4 plen: 4 vdim: 4\nhyper_ratio 0.0625\nGraphBLAS type:  int8_t size: 1\nnumber of entries: 5\nrow: 1 : 1 entries [0:0]\n    column 1: int8 2\nrow: 2 : 3 entries [1:3]\n    column 1: int8 4\n    column 2: int8 3\n    column 3: int8 5\nrow: 3 : 1 entries [4:4]\n    column 3: int8 6\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Matrix_clear","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Matrix_clear","text":"GrB_Matrix_clear(A)\n\nRemove all elements from a matrix.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [1, 2, 2, 2, 3]; J = [1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_nvals(MAT)\n5\n\njulia> GrB_Matrix_clear(MAT)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_nvals(MAT)\n0\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#Vector-functions-1","page":"Basic matrix & vector methods","title":"Vector functions","text":"","category":"section"},{"location":"matrix_and_vector_methods/#","page":"Basic matrix & vector methods","title":"Basic matrix & vector methods","text":"GrB_Vector\nGrB_Vector_new\nGrB_Vector_build\nGrB_Vector_size\nGrB_Vector_nvals\nGrB_Vector_setElement\nGrB_Vector_extractElement\nGrB_Vector_extractTuples\nGrB_Vector_dup\nGrB_Vector_clear","category":"page"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Vector","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Vector","text":"GrB_Vector(varargs...)\n\nCreate a new NULL GraphBLAS vector.\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Vector_new","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Vector_new","text":"GrB_Vector_new(v, type, n)\n\nInitialize a vector with specified domain and size.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(V, GrB_FP64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Vector_build","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Vector_build","text":"GrB_Vector_build(w, I, X, nvals, dup)\n\nStore elements from tuples into a vector.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(V, GrB_FP64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 2, 3]; X = [2.1, 3.2, 4.4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Vector_fprint(V, GxB_SHORT)\n\nGraphBLAS vector: V\nnrows: 4 ncols: 1 max # entries: 3\nformat: standard CSC vlen: 4 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  double size: 8\nnumber of entries: 3\ncolumn: 0 : 3 entries [0:2]\n    row 0: double 2.1\n    row 2: double 3.2\n    row 3: double 4.4\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Vector_size","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Vector_size","text":"GrB_Vector_size(v)\n\nReturn the size of a vector if successful. Else return GrB_Info error code.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(V, GrB_FP64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 2, 3]; X = [2.1, 3.2, 4.4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_size(V)\n4\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Vector_nvals","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Vector_nvals","text":"GrB_Vector_nvals(v)\n\nReturn the number of stored elements in a vector if successful. Else return GrB_Info error code.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(V, GrB_FP64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 2, 3]; X = [2.1, 3.2, 4.4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_nvals(V)\n3\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Vector_setElement","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Vector_setElement","text":"GrB_Vector_setElement(w, x, i)\n\nSet one element of a vector to a given value, w[i] = x.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(V, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [1, 2, 4]; X = [2, 32, 4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractElement(V, 2)\n32\n\njulia> GrB_Vector_setElement(V, 7, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractElement(V, 2)\n7\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Vector_extractElement","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Vector_extractElement","text":"GrB_Vector_extractElement(v, i)\n\nReturn element of a vector at a given index (v[i]) if successful. Else return GrB_Info error code.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(V, GrB_FP64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 2, 3]; X = [2.1, 3.2, 4.4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractElement(V, 2)\n3.2\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Vector_extractTuples","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Vector_extractTuples","text":"GrB_Vector_extractTuples(v)\n\nReturn tuples stored in a vector if successful. Else return GrB_Info error code.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(V, GrB_FP64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 2, 3]; X = [2.1, 3.2, 4.4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(V)\n([0, 2, 3], [2.1, 3.2, 4.4])\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Vector_dup","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Vector_dup","text":"GrB_Vector_dup(w, u)\n\nInitialize a vector with the same domain, size, and contents as another vector.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(V, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [1, 2, 4]; X = [2, 32, 4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> B = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_dup(B, V)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Vector_fprint(B, GxB_SHORT)\n\nGraphBLAS vector: B\nnrows: 5 ncols: 1 max # entries: 3\nformat: standard CSC vlen: 5 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 3\ncolumn: 0 : 3 entries [0:2]\n    row 1: int64 2\n    row 2: int64 32\n    row 4: int64 4\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Vector_clear","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Vector_clear","text":"GrB_Vector_clear(v)\n\nRemove all the elements (tuples) from a vector.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(V, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [1, 2, 4]; X = [2, 32, 4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(V)\n([1, 2, 4], [2, 32, 4])\n\njulia> GrB_Vector_clear(V)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(V)\n(Int64[], Int64[])\n\n\n\n\n\n","category":"function"},{"location":"algebra_methods/#Algebra-methods-1","page":"Operators & algebraic structures","title":"Algebra methods","text":"","category":"section"},{"location":"algebra_methods/#","page":"Operators & algebraic structures","title":"Operators & algebraic structures","text":"GrB_Type\nGrB_Type_new\nGrB_UnaryOp\nGrB_UnaryOp_new\nGrB_BinaryOp\nGrB_BinaryOp_new\nGrB_Monoid\nGrB_Monoid_new\nGrB_Semiring\nGrB_Semiring_new","category":"page"},{"location":"algebra_methods/#GraphBLASInterface.GrB_Type","page":"Operators & algebraic structures","title":"GraphBLASInterface.GrB_Type","text":"GrB_Type(varargs...)\n\nCreate a new NULL GraphBLAS type.\n\n\n\n\n\n","category":"function"},{"location":"algebra_methods/#GraphBLASInterface.GrB_Type_new","page":"Operators & algebraic structures","title":"GraphBLASInterface.GrB_Type_new","text":"GrB_Type_new(type, sizeof_type)\n\nInitialize a GraphBLAS type with its size.\n\n\n\n\n\n","category":"function"},{"location":"algebra_methods/#GraphBLASInterface.GrB_UnaryOp","page":"Operators & algebraic structures","title":"GraphBLASInterface.GrB_UnaryOp","text":"GrB_UnaryOp(varargs...)\n\nCreate a new NULL GraphBLAS unary operator.\n\n\n\n\n\n","category":"function"},{"location":"algebra_methods/#GraphBLASInterface.GrB_UnaryOp_new","page":"Operators & algebraic structures","title":"GraphBLASInterface.GrB_UnaryOp_new","text":"GrB_UnaryOp_new(op, fn, ztype, xtype)\n\nInitialize a GraphBLAS unary operator with a specified user-defined function and its types. The function should take a single value(x) & return an output(z), f(x) = z.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 3)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 2]; X = [10, 20]; n = 2;\n\njulia> GrB_Vector_build(u, I, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(w, GrB_INT64, 3)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> function NEG(a)\n           return -a\n       end\nNEG (generic function with 1 method)\n\njulia> negative = GrB_UnaryOp()\nGrB_UnaryOp\n\njulia> GrB_UnaryOp_new(negative, NEG, GrB_INT64, GrB_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_apply(w, GrB_NULL, GrB_NULL, negative, u, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(w, GxB_COMPLETE)\n\nGraphBLAS vector: w \nnrows: 3 ncols: 1 max # entries: 2\nformat: standard CSC vlen: 3 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 2 \ncolumn: 0 : 2 entries [0:1]\n    row 0: int64 -10\n    row 2: int64 -20\n\n\n\n\n\n\n","category":"function"},{"location":"algebra_methods/#GraphBLASInterface.GrB_BinaryOp","page":"Operators & algebraic structures","title":"GraphBLASInterface.GrB_BinaryOp","text":"GrB_BinaryOp(varargs...)\n\nCreate a new NULL GraphBLAS binary operator.\n\n\n\n\n\n","category":"function"},{"location":"algebra_methods/#GraphBLASInterface.GrB_BinaryOp_new","page":"Operators & algebraic structures","title":"GraphBLASInterface.GrB_BinaryOp_new","text":"GrB_BinaryOp_new(op, fn, ztype, xtype, ytype)\n\nInitialize a GraphBLAS binary operator with a specified user-defined function and its types. The function should take 2 values(x, y) & return an output(z), f(x, y) = z.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(V, GrB_FP64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 0, 3, 3]; X = [2.1, 3.2, 4.5, 5.0]; n = 4;  # two values at position 0 and 3\n\njulia> dup = GrB_BinaryOp()  # dup is a binary operator which is applied when duplicate values for the same location are present in the vector\nGrB_BinaryOp\n\njulia> function ADD(b, c)\n           return b+c\n       end\nADD (generic function with 1 method)\n\njulia> GrB_BinaryOp_new(dup, ADD, GrB_FP64, GrB_FP64, GrB_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_build(V, I, X, n, dup)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Vector_fprint(V, GxB_SHORT) # the value stored at position 0 and 3 will be the sum of the duplicate values\n\nGraphBLAS vector: V\nnrows: 4 ncols: 1 max # entries: 2\nformat: standard CSC vlen: 4 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  double size: 8\nnumber of entries: 2\ncolumn: 0 : 2 entries [0:1]\n    row 0: double 5.3\n    row 3: double 9.5\n\n\n\n\n\n\n","category":"function"},{"location":"algebra_methods/#GraphBLASInterface.GrB_Monoid","page":"Operators & algebraic structures","title":"GraphBLASInterface.GrB_Monoid","text":"GrB_Monoid(varargs...)\n\nCreate a new NULL GraphBLAS monoid.\n\n\n\n\n\n","category":"function"},{"location":"algebra_methods/#GraphBLASInterface.GrB_Monoid_new","page":"Operators & algebraic structures","title":"GraphBLASInterface.GrB_Monoid_new","text":"GrB_Monoid_new(monoid, binary_op, identity)\n\nInitialize a GraphBLAS monoid with specified binary operator and identity value.\n\n\n\n\n\n","category":"function"},{"location":"algebra_methods/#GraphBLASInterface.GrB_Semiring","page":"Operators & algebraic structures","title":"GraphBLASInterface.GrB_Semiring","text":"GrB_Semiring(varargs...)\n\nCreate a new NULL GraphBLAS semiring.\n\n\n\n\n\n","category":"function"},{"location":"algebra_methods/#GraphBLASInterface.GrB_Semiring_new","page":"Operators & algebraic structures","title":"GraphBLASInterface.GrB_Semiring_new","text":"GrB_Semiring_new(semiring, monoid, binary_op)\n\nInitialize a GraphBLAS semiring with specified monoid and binary operator.\n\n\n\n\n\n","category":"function"},{"location":"algebra_methods/#Built-in-algebraic-objects-1","page":"Operators & algebraic structures","title":"Built-in algebraic objects","text":"","category":"section"},{"location":"algebra_methods/#Unary-operators,-z-f(x)-1","page":"Operators & algebraic structures","title":"Unary operators, z = f(x)","text":"","category":"section"},{"location":"algebra_methods/#","page":"Operators & algebraic structures","title":"Operators & algebraic structures","text":"z and x have the same type. The suffix in the name is the type of x and z.\n\nz = x                z = -x            z = 1/x\nidentity             additive          multiplicative\n                     inverse           inverse\n\nGrB_IDENTITY_BOOL    GrB_AINV_BOOL     GrB_MINV_BOOL\nGrB_IDENTITY_INT8    GrB_AINV_INT8     GrB_MINV_INT8\nGrB_IDENTITY_UINT8   GrB_AINV_UINT8    GrB_MINV_UINT8\nGrB_IDENTITY_INT16   GrB_AINV_INT16    GrB_MINV_INT16\nGrB_IDENTITY_UINT16  GrB_AINV_UINT16   GrB_MINV_UINT16\nGrB_IDENTITY_INT32   GrB_AINV_INT32    GrB_MINV_INT32\nGrB_IDENTITY_UINT32  GrB_AINV_UINT32   GrB_MINV_UINT32\nGrB_IDENTITY_INT64   GrB_AINV_INT64    GrB_MINV_INT64\nGrB_IDENTITY_UINT64  GrB_AINV_UINT64   GrB_MINV_UINT64\nGrB_IDENTITY_FP32    GrB_AINV_FP32     GrB_MINV_FP32\nGrB_IDENTITY_FP64    GrB_AINV_FP64     GrB_MINV_FP64\n\nz = !x, where both z and x are boolean. \nThere is no suffix since z and x are only boolean.\n\nGrB_LNOT","category":"page"},{"location":"algebra_methods/#Binary-operators,-z-f(x,y)-1","page":"Operators & algebraic structures","title":"Binary operators, z = f(x,y)","text":"","category":"section"},{"location":"algebra_methods/#","page":"Operators & algebraic structures","title":"Operators & algebraic structures","text":"x,y,z all have the same type :\n\nz = x              z = y              z = min(x,y)       z = max (x,y)\n\nGrB_FIRST_BOOL     GrB_SECOND_BOOL    GrB_MIN_BOOL       GrB_MAX_BOOL\nGrB_FIRST_INT8     GrB_SECOND_INT8    GrB_MIN_INT8       GrB_MAX_INT8\nGrB_FIRST_UINT8    GrB_SECOND_UINT8   GrB_MIN_UINT8      GrB_MAX_UINT8\nGrB_FIRST_INT16    GrB_SECOND_INT16   GrB_MIN_INT16      GrB_MAX_INT16\nGrB_FIRST_UINT16   GrB_SECOND_UINT16  GrB_MIN_UINT16     GrB_MAX_UINT16\nGrB_FIRST_INT32    GrB_SECOND_INT32   GrB_MIN_INT32      GrB_MAX_INT32\nGrB_FIRST_UINT32   GrB_SECOND_UINT32  GrB_MIN_UINT32     GrB_MAX_UINT32\nGrB_FIRST_INT64    GrB_SECOND_INT64   GrB_MIN_INT64      GrB_MAX_INT64\nGrB_FIRST_UINT64   GrB_SECOND_UINT64  GrB_MIN_UINT64     GrB_MAX_UINT64\nGrB_FIRST_FP32     GrB_SECOND_FP32    GrB_MIN_FP32       GrB_MAX_FP32\nGrB_FIRST_FP64     GrB_SECOND_FP64    GrB_MIN_FP64       GrB_MAX_FP64\n\nz = x+y            z = x-y            z = x*y            z = x/y\n\nGrB_PLUS_BOOL      GrB_MINUS_BOOL     GrB_TIMES_BOOL     GrB_DIV_BOOL\nGrB_PLUS_INT8      GrB_MINUS_INT8     GrB_TIMES_INT8     GrB_DIV_INT8\nGrB_PLUS_UINT8     GrB_MINUS_UINT8    GrB_TIMES_UINT8    GrB_DIV_UINT8\nGrB_PLUS_INT16     GrB_MINUS_INT16    GrB_TIMES_INT16    GrB_DIV_INT16\nGrB_PLUS_UINT16    GrB_MINUS_UINT16   GrB_TIMES_UINT16   GrB_DIV_UINT16\nGrB_PLUS_INT32     GrB_MINUS_INT32    GrB_TIMES_INT32    GrB_DIV_INT32\nGrB_PLUS_UINT32    GrB_MINUS_UINT32   GrB_TIMES_UINT32   GrB_DIV_UINT32\nGrB_PLUS_INT64     GrB_MINUS_INT64    GrB_TIMES_INT64    GrB_DIV_INT64\nGrB_PLUS_UINT64    GrB_MINUS_UINT64   GrB_TIMES_UINT64   GrB_DIV_UINT64\nGrB_PLUS_FP32      GrB_MINUS_FP32     GrB_TIMES_FP32     GrB_DIV_FP32\nGrB_PLUS_FP64      GrB_MINUS_FP64     GrB_TIMES_FP64     GrB_DIV_FP64\n\nz is always boolean & x,y have the same type :\n\nz = (x == y)       z = (x != y)       z = (x > y)        z = (x < y)\n\nGrB_EQ_BOOL        GrB_NE_BOOL        GrB_GT_BOOL        GrB_LT_BOOL\nGrB_EQ_INT8        GrB_NE_INT8        GrB_GT_INT8        GrB_LT_INT8\nGrB_EQ_UINT8       GrB_NE_UINT8       GrB_GT_UINT8       GrB_LT_UINT8\nGrB_EQ_INT16       GrB_NE_INT16       GrB_GT_INT16       GrB_LT_INT16\nGrB_EQ_UINT16      GrB_NE_UINT16      GrB_GT_UINT16      GrB_LT_UINT16\nGrB_EQ_INT32       GrB_NE_INT32       GrB_GT_INT32       GrB_LT_INT32\nGrB_EQ_UINT32      GrB_NE_UINT32      GrB_GT_UINT32      GrB_LT_UINT32\nGrB_EQ_INT64       GrB_NE_INT64       GrB_GT_INT64       GrB_LT_INT64\nGrB_EQ_UINT64      GrB_NE_UINT64      GrB_GT_UINT64      GrB_LT_UINT64\nGrB_EQ_FP32        GrB_NE_FP32        GrB_GT_FP32        GrB_LT_FP32\nGrB_EQ_FP64        GrB_NE_FP64        GrB_GT_FP64        GrB_LT_FP64\n\nz = (x >= y)       z = (x <= y)\n\nGrB_GE_BOOL        GrB_LE_BOOL\nGrB_GE_INT8        GrB_LE_INT8\nGrB_GE_UINT8       GrB_LE_UINT8\nGrB_GE_INT16       GrB_LE_INT16\nGrB_GE_UINT16      GrB_LE_UINT16\nGrB_GE_INT32       GrB_LE_INT32\nGrB_GE_UINT32      GrB_LE_UINT32\nGrB_GE_INT64       GrB_LE_INT64\nGrB_GE_UINT64      GrB_LE_UINT64\nGrB_GE_FP32        GrB_LE_FP32\nGrB_GE_FP64        GrB_LE_FP64\n\nx,y,z all are boolean :\n\nz = (x || y)       z = (x && y)       z = (x != y)\n\nGrB_LOR            GrB_LAND           GrB_LXOR","category":"page"},{"location":"desc_methods/#Descriptor-methods-1","page":"Descriptors","title":"Descriptor methods","text":"","category":"section"},{"location":"desc_methods/#","page":"Descriptors","title":"Descriptors","text":"GrB_Descriptor\nGrB_Descriptor_new\nGrB_Descriptor_set","category":"page"},{"location":"desc_methods/#GraphBLASInterface.GrB_Descriptor","page":"Descriptors","title":"GraphBLASInterface.GrB_Descriptor","text":"GrB_Descriptor(varargs...)\n\nCreate a new NULL GraphBLAS descriptor.\n\n\n\n\n\n","category":"function"},{"location":"desc_methods/#GraphBLASInterface.GrB_Descriptor_new","page":"Descriptors","title":"GraphBLASInterface.GrB_Descriptor_new","text":"GrB_Descriptor_new(desc)\n\nInitialize a descriptor with default field values.\n\n\n\n\n\n","category":"function"},{"location":"desc_methods/#GraphBLASInterface.GrB_Descriptor_set","page":"Descriptors","title":"GraphBLASInterface.GrB_Descriptor_set","text":"GrB_Descriptor_set(desc, field, val)\n\nSet the content for a field for an existing descriptor.\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#Free-methods-1","page":"Freeing objects","title":"Free methods","text":"","category":"section"},{"location":"free_methods/#","page":"Freeing objects","title":"Freeing objects","text":"GrB_free\nGrB_Type_free\nGrB_UnaryOp_free\nGrB_BinaryOp_free\nGrB_Monoid_free\nGrB_Semiring_free\nGrB_Matrix_free\nGrB_Vector_free\nGrB_Descriptor_free","category":"page"},{"location":"free_methods/#GraphBLASInterface.GrB_free","page":"Freeing objects","title":"GraphBLASInterface.GrB_free","text":"GrB_free(object)\n\nGeneric method to free a GraphBLAS object.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> w = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> I = [0, 2, 4]; X = [10, 20, 30]; n = 3;\n\njulia> GrB_Vector_new(w, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_build(w, I, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(w, GxB_COMPLETE)\n\nGraphBLAS vector: w\nnrows: 5 ncols: 1 max # entries: 3\nformat: standard CSC vlen: 5 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 3\ncolumn: 0 : 3 entries [0:2]\n    row 0: int64 10\n    row 2: int64 20\n    row 4: int64 30\n\n\njulia> GrB_free(w)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(w, GxB_COMPLETE)\n\nGraphBLAS vector: w NULL\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#GraphBLASInterface.GrB_Type_free","page":"Freeing objects","title":"GraphBLASInterface.GrB_Type_free","text":"GrB_Type_free(unaryop)\n\nFree GraphBLAS user-defined type.\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#GraphBLASInterface.GrB_UnaryOp_free","page":"Freeing objects","title":"GraphBLASInterface.GrB_UnaryOp_free","text":"GrB_UnaryOp_free(unaryop)\n\nFree unary operator.\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#GraphBLASInterface.GrB_BinaryOp_free","page":"Freeing objects","title":"GraphBLASInterface.GrB_BinaryOp_free","text":"GrB_BinaryOp_free(binaryop)\n\nFree binary operator.\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#GraphBLASInterface.GrB_Monoid_free","page":"Freeing objects","title":"GraphBLASInterface.GrB_Monoid_free","text":"GrB_Monoid_free(monoid)\n\nFree monoid.\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#GraphBLASInterface.GrB_Semiring_free","page":"Freeing objects","title":"GraphBLASInterface.GrB_Semiring_free","text":"GrB_Semiring_free(semiring)\n\nFree semiring.\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#GraphBLASInterface.GrB_Matrix_free","page":"Freeing objects","title":"GraphBLASInterface.GrB_Matrix_free","text":"GrB_Matrix_free(A)\n\nFree matrix.\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#GraphBLASInterface.GrB_Vector_free","page":"Freeing objects","title":"GraphBLASInterface.GrB_Vector_free","text":"GrB_Vector_free(v)\n\nFree vector.\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#GraphBLASInterface.GrB_Descriptor_free","page":"Freeing objects","title":"GraphBLASInterface.GrB_Descriptor_free","text":"GrB_Descriptor_free(desc)\n\nFree descriptor.\n\n\n\n\n\n","category":"function"},{"location":"seq_ter/#Sequence-termination-1","page":"Sequence termination","title":"Sequence termination","text":"","category":"section"},{"location":"seq_ter/#","page":"Sequence termination","title":"Sequence termination","text":"GrB_wait\nGrB_error","category":"page"},{"location":"seq_ter/#GraphBLASInterface.GrB_wait","page":"Sequence termination","title":"GraphBLASInterface.GrB_wait","text":"GrB_wait()\n\nGrB_wait forces all pending operations to complete. Blocking mode is as if GrB_wait is called whenever a GraphBLAS method or operation returns to the user.\n\n\n\n\n\n","category":"function"},{"location":"seq_ter/#GraphBLASInterface.GrB_error","page":"Sequence termination","title":"GraphBLASInterface.GrB_error","text":"GrB_error()\n\nEach GraphBLAS method and operation returns a GrB_Info error code. GrB_error returns additional information on the last error.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_INVALID_VALUE::GrB_Info = 5\n\njulia> GrB_error()\nGraphBLAS error: GrB_INVALID_VALUE\nfunction: GrB_init (mode)\nGrB_init must not be called twice\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLAS-operations-1","page":"Operations","title":"GraphBLAS operations","text":"","category":"section"},{"location":"operations/#Multiplication-1","page":"Operations","title":"Multiplication","text":"","category":"section"},{"location":"operations/#","page":"Operations","title":"Operations","text":"GrB_mxm\nGrB_vxm\nGrB_mxv","category":"page"},{"location":"operations/#GraphBLASInterface.GrB_mxm","page":"Operations","title":"GraphBLASInterface.GrB_mxm","text":"GrB_mxm(C, Mask, accum, semiring, A, B, desc)\n\nMultiplies a matrix with another matrix on a semiring. The result is a matrix.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 2, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = [0, 1]; J1 = [0, 1]; X1 = [10, 20]; n1 = 2;\n\njulia> GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> B = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(B, GrB_INT64, 2, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = [0, 1]; J2 = [0, 1]; X2 = [5, 15]; n2 = 2;\n\njulia> GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> C = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(C, GrB_INT64, 2, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_mxm(C, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_INT64, A, B, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractTuples(C)\n([0, 1], [0, 1], [50, 300])\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_vxm","page":"Operations","title":"GraphBLASInterface.GrB_vxm","text":"GrB_vxm(w, mask, accum, semiring, u, A, desc)\n\nMultiplies a (row)vector with a matrix on an semiring. The result is a vector.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 2, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = [0, 1]; J1 = [0, 1]; X1 = [10, 20]; n1 = 2;\n\njulia> GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = [0, 1]; X2 = [5, 6]; n2 = 2;\n\njulia> GrB_Vector_build(u, I2, X2, n2, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(w, GrB_INT64, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_vxm(w, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_INT64, u, A, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(w)\n([0, 1], [50, 120])\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_mxv","page":"Operations","title":"GraphBLASInterface.GrB_mxv","text":"GrB_mxv(w, mask, accum, semiring, A, u, desc)\n\nMultiplies a matrix by a vector on a semiring. The result is a vector.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 2, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = [0, 0, 1]; J1 = [0, 1, 1]; X1 = [10, 20, 30]; n1 = 3;\n\njulia> GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = [0, 1]; X2 = [5, 6]; n2 = 2;\n\njulia> GrB_Vector_build(u, I2, X2, n2, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(w, GrB_INT64, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_mxv(w, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_INT64, A, u, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(w)\n([0, 1], [170, 180])\n\n\n\n\n\n","category":"function"},{"location":"operations/#Element-wise-multiplication-1","page":"Operations","title":"Element-wise multiplication","text":"","category":"section"},{"location":"operations/#","page":"Operations","title":"Operations","text":"GrB_eWiseMult\nGrB_eWiseMult_Vector_Semiring\nGrB_eWiseMult_Vector_Monoid\nGrB_eWiseMult_Vector_BinaryOp\nGrB_eWiseMult_Matrix_Semiring\nGrB_eWiseMult_Matrix_Monoid\nGrB_eWiseMult_Matrix_BinaryOp","category":"page"},{"location":"operations/#GraphBLASInterface.GrB_eWiseMult","page":"Operations","title":"GraphBLASInterface.GrB_eWiseMult","text":"GrB_eWiseMult(C, mask, accum, op, A, B, desc)\n\nGeneric method for element-wise matrix and vector operations: using set intersection.\n\nGrB_eWiseMult computes C<Mask> = accum (C, A .* B), where pairs of elements in two matrices (or vectors) are pairwise \"multiplied\" with C(i, j) = mult (A(i, j), B(i, j)). The \"multiplication\" operator can be any binary operator. The pattern of the result T = A .* B is the set intersection (not union) of A and B. Entries outside of the intersection are not computed. This is primary difference with GrB_eWiseAdd. The input matrices A and/or B may be transposed first, via the descriptor. For a semiring, the mult operator is the semiring's multiply operator; this differs from the eWiseAdd methods which use the semiring's add operator instead.\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseMult_Vector_Semiring","page":"Operations","title":"GraphBLASInterface.GrB_eWiseMult_Vector_Semiring","text":"GrB_eWiseMult_Vector_Semiring(w, mask, accum, semiring, u, v, desc)\n\nCompute element-wise vector multiplication using semiring. Semiring's multiply operator is used. w<mask> = accum (w, u .* v)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = [0, 2, 4]; X1 = [10, 20, 3]; n1 = 3;\n\njulia> GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> v = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(v, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = [0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;\n\njulia> GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(w, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseMult_Vector_Semiring(w, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_FP64, u, v, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(w)\n([0, 4], [11.0, 9.9])\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseMult_Vector_Monoid","page":"Operations","title":"GraphBLASInterface.GrB_eWiseMult_Vector_Monoid","text":"GrB_eWiseMult_Vector_Monoid(w, mask, accum, monoid, u, v, desc)\n\nCompute element-wise vector multiplication using monoid. w<mask> = accum (w, u .* v)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = [0, 2, 4]; X1 = [10, 20, 3]; n1 = 3;\n\njulia> GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> v = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(v, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = [0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;\n\njulia> GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(w, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseMult_Vector_Monoid(w, GrB_NULL, GrB_NULL, GxB_MAX_FP64_MONOID, u, v, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(w)\n([0, 4], [10.0, 3.3])\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseMult_Vector_BinaryOp","page":"Operations","title":"GraphBLASInterface.GrB_eWiseMult_Vector_BinaryOp","text":"GrB_eWiseMult_Vector_BinaryOp(w, mask, accum, mult, u, v, desc)\n\nCompute element-wise vector multiplication using binary operator. w<mask> = accum (w, u .* v)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = [0, 2, 4]; X1 = [10, 20, 30]; n1 = 3;\n\njulia> GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> v = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(v, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = [0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;\n\njulia> GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(w, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseMult_Vector_BinaryOp(w, GrB_NULL, GrB_NULL, GrB_TIMES_FP64, u, v, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(w)\n([0, 4], [11.0, 99.0])\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseMult_Matrix_Semiring","page":"Operations","title":"GraphBLASInterface.GrB_eWiseMult_Matrix_Semiring","text":"GrB_eWiseMult_Matrix_Semiring(C, Mask, accum, semiring, A, B, desc)\n\nCompute element-wise matrix multiplication using semiring. Semiring's multiply operator is used. C<Mask> = accum (C, A .* B)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = [0, 0, 2, 2]; J1 = [1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;\n\njulia> GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> B = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(B, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = [0, 0, 2]; J2 = [3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;\n\njulia> GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> C = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(C, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseMult_Matrix_Semiring(C, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_INT64, A, B, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractTuples(C)\n([0, 2], [2, 0], [320, 510])\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseMult_Matrix_Monoid","page":"Operations","title":"GraphBLASInterface.GrB_eWiseMult_Matrix_Monoid","text":"GrB_eWiseMult_Matrix_Monoid(C, Mask, accum, monoid, A, B, desc)\n\nCompute element-wise matrix multiplication using monoid. C<Mask> = accum (C, A .* B)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = [0, 0, 2, 2]; J1 = [1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;\n\njulia> GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> B = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(B, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = [0, 0, 2]; J2 = [3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;\n\njulia> GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> C = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(C, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseMult_Matrix_Monoid(C, GrB_NULL, GrB_NULL, GxB_PLUS_INT64_MONOID, A, B, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractTuples(C)\n([0, 2], [2, 0], [36, 47])\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseMult_Matrix_BinaryOp","page":"Operations","title":"GraphBLASInterface.GrB_eWiseMult_Matrix_BinaryOp","text":"GrB_eWiseMult_Matrix_BinaryOp(C, Mask, accum, mult, A, B, desc)\n\nCompute element-wise matrix multiplication using binary operator. C<Mask> = accum (C, A .* B)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = [0, 0, 2, 2]; J1 = [1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;\n\njulia> GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> B = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(B, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = [0, 0, 2]; J2 = [3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;\n\njulia> GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> C = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(C, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseMult_Matrix_BinaryOp(C, GrB_NULL, GrB_NULL, GrB_PLUS_INT64, A, B, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractTuples(C)\n([0, 2], [2, 0], [36, 47])\n\n\n\n\n\n","category":"function"},{"location":"operations/#Element-wise-addition-1","page":"Operations","title":"Element-wise addition","text":"","category":"section"},{"location":"operations/#","page":"Operations","title":"Operations","text":"GrB_eWiseAdd\nGrB_eWiseAdd_Vector_Semiring\nGrB_eWiseAdd_Vector_Monoid\nGrB_eWiseAdd_Vector_BinaryOp\nGrB_eWiseAdd_Matrix_Semiring\nGrB_eWiseAdd_Matrix_Monoid\nGrB_eWiseAdd_Matrix_BinaryOp","category":"page"},{"location":"operations/#GraphBLASInterface.GrB_eWiseAdd","page":"Operations","title":"GraphBLASInterface.GrB_eWiseAdd","text":"GrB_eWiseAdd(C, mask, accum, op, A, B, desc)\n\nGeneric method for element-wise matrix and vector operations: using set union.\n\nGrB_eWiseAdd computes C<Mask> = accum (C, A + B), where pairs of elements in two matrices (or two vectors) are pairwise \"added\". The \"add\" operator can be any binary operator. With the plus operator, this is the same matrix addition in conventional linear algebra. The pattern of the result T = A + B is the set union of A and B. Entries outside of the union are not computed. That is, if both A(i, j) and B(i, j) are present in the pattern of A and B, then T(i, j) = A(i, j) \"+\" B(i, j). If only A(i, j) is present then T(i, j) = A (i, j) and the \"+\" operator is not used. Likewise, if only B(i, j) is in the pattern of B but A(i, j) is not in the pattern of A, then T(i, j) = B(i, j). For a semiring, the mult operator is the semiring's add operator.\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseAdd_Vector_Semiring","page":"Operations","title":"GraphBLASInterface.GrB_eWiseAdd_Vector_Semiring","text":"GrB_eWiseAdd_Vector_Semiring(w, mask, accum, semiring, u, v, desc)\n\nCompute element-wise vector addition using semiring. Semiring's add operator is used. w<mask> = accum (w, u + v)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = [0, 2, 4]; X1 = [10, 20, 3]; n1 = 3;\n\njulia> GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> v = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(v, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = [0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;\n\njulia> GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(w, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseAdd_Vector_Semiring(w, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_FP64, u, v, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(w)\n([0, 1, 2, 4], [11.1, 2.2, 20.0, 6.3])\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseAdd_Vector_Monoid","page":"Operations","title":"GraphBLASInterface.GrB_eWiseAdd_Vector_Monoid","text":"GrB_eWiseAdd_Vector_Monoid(w, mask, accum, monoid, u, v, desc)\n\nCompute element-wise vector addition using monoid. w<mask> = accum (w, u + v)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = [0, 2, 4]; X1 = [10, 20, 3]; n1 = 3;\n\njulia> GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> v = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(v, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = [0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;\n\njulia> GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(w, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseAdd_Vector_Monoid(w, GrB_NULL, GrB_NULL, GxB_MAX_FP64_MONOID, u, v, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(w)\n([0, 1, 2, 4], [10.0, 2.2, 20.0, 3.3])\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseAdd_Vector_BinaryOp","page":"Operations","title":"GraphBLASInterface.GrB_eWiseAdd_Vector_BinaryOp","text":"GrB_eWiseAdd_Vector_BinaryOp(w, mask, accum, add, u, v, desc)\n\nCompute element-wise vector addition using binary operator. w<mask> = accum (w, u + v)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = [0, 2, 4]; X1 = [10, 20, 3]; n1 = 3;\n\njulia> GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> v = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(v, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = [0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;\n\njulia> GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(w, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseAdd_Vector_BinaryOp(w, GrB_NULL, GrB_NULL, GrB_PLUS_FP64, u, v, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(w)\n([0, 1, 2, 4], [11.1, 2.2, 20.0, 6.3])\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseAdd_Matrix_Semiring","page":"Operations","title":"GraphBLASInterface.GrB_eWiseAdd_Matrix_Semiring","text":"GrB_eWiseAdd_Matrix_Semiring(C, Mask, accum, semiring, A, B, desc)\n\nCompute element-wise matrix addition using semiring. Semiring's add operator is used. C<Mask> = accum (C, A + B)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = [0, 0, 2, 2]; J1 = [1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;\n\njulia> GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> B = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(B, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = [0, 0, 2]; J2 = [3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;\n\njulia> GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> C = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(C, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseAdd_Matrix_Semiring(C, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_INT64, A, B, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractTuples(C)\n([0, 0, 0, 2, 2], [1, 2, 3, 0, 2], [10, 36, 15, 47, 40])\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseAdd_Matrix_Monoid","page":"Operations","title":"GraphBLASInterface.GrB_eWiseAdd_Matrix_Monoid","text":"GrB_eWiseAdd_Matrix_Monoid(C, Mask, accum, monoid, A, B, desc)\n\nCompute element-wise matrix addition using monoid. C<Mask> = accum (C, A + B)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = [0, 0, 2, 2]; J1 = [1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;\n\njulia> GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> B = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(B, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = [0, 0, 2]; J2 = [3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;\n\njulia> GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> C = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(C, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> mask = GrB_Matrix{Bool}()\nGrB_Matrix{Bool}\n\njulia> GrB_Matrix_new(mask, GrB_BOOL, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_build(mask, [0, 0], [1, 2], [true, true], 2, GrB_FIRST_BOOL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseAdd_Matrix_Monoid(C, mask, GrB_NULL, GxB_PLUS_INT64_MONOID, A, B, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractTuples(C)\n([0, 0], [1, 2], [10, 36])\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseAdd_Matrix_BinaryOp","page":"Operations","title":"GraphBLASInterface.GrB_eWiseAdd_Matrix_BinaryOp","text":"GrB_eWiseAdd_Matrix_BinaryOp(C, Mask, accum, add, A, B, desc)\n\nCompute element-wise matrix addition using binary operator. C<Mask> = accum (C, A + B)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = [0, 0, 2, 2]; J1 = [1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;\n\njulia> GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> B = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(B, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = [0, 0, 2]; J2 = [3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;\n\njulia> GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> C = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(C, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseAdd_Matrix_BinaryOp(C, GrB_NULL, GrB_NULL, GrB_PLUS_INT64, A, B, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractTuples(C)\n([0, 0, 0, 2, 2], [1, 2, 3, 0, 2], [10, 36, 15, 47, 40])\n\n\n\n\n\n","category":"function"},{"location":"operations/#Extract-1","page":"Operations","title":"Extract","text":"","category":"section"},{"location":"operations/#","page":"Operations","title":"Operations","text":"GrB_extract\nGrB_Vector_extract\nGrB_Matrix_extract\nGrB_Col_extract","category":"page"},{"location":"operations/#GraphBLASInterface.GrB_extract","page":"Operations","title":"GraphBLASInterface.GrB_extract","text":"GrB_extract(arg1, Mask, accum, arg4, ...)\n\nGeneric matrix/vector extraction.\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Vector_extract","page":"Operations","title":"GraphBLASInterface.GrB_Vector_extract","text":"GrB_Vector_extract(w, mask, accum, u, I, ni, desc)\n\nExtract a sub-vector from a larger vector as specified by a set of indices. The result is a vector whose size is equal to the number of indices.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(V, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [1, 2, 4]; X = [15, 32, 84]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Vector_fprint(V, GxB_COMPLETE)\n\nGraphBLAS vector: V\nnrows: 5 ncols: 1 max # entries: 3\nformat: standard CSC vlen: 5 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 3\ncolumn: 0 : 3 entries [0:2]\n    row 1: int64 15\n    row 2: int64 32\n    row 4: int64 84\n\n\njulia> W = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(W, GrB_INT64, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extract(W, GrB_NULL, GrB_NULL, V, [1, 4], 2, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(W)[2]\n2-element Array{Int64,1}:\n 15\n 84\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Matrix_extract","page":"Operations","title":"GraphBLASInterface.GrB_Matrix_extract","text":"GrB_Matrix_extract(C, Mask, accum, A, I, ni, J, nj, desc)\n\nExtract a sub-matrix from a larger matrix as specified by a set of row indices and a set of column indices. The result is a matrix whose size is equal to size of the sets of indices.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [1, 2, 2, 2, 3]; J = [1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;\n\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Matrix_fprint(MAT, GxB_COMPLETE)\n\nGraphBLAS matrix: MAT \nnrows: 4 ncols: 4 max # entries: 5\nformat: standard CSR vlen: 4 nvec_nonempty: 3 nvec: 4 plen: 4 vdim: 4\nhyper_ratio 0.0625\nGraphBLAS type:  int8_t size: 1\nnumber of entries: 5 \nrow: 1 : 1 entries [0:0]\n    column 1: int8 2\nrow: 2 : 3 entries [1:3]\n    column 1: int8 4\n    column 2: int8 3\n    column 3: int8 5\nrow: 3 : 1 entries [4:4]\n    column 3: int8 6\n\n\njulia> OUT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(OUT, GrB_INT8, 2, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extract(OUT, GrB_NULL, GrB_NULL, MAT, [1, 3], 2, [1, 3], 2, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractTuples(OUT)[3]\n2-element Array{Int8,1}:\n 2\n 6\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Col_extract","page":"Operations","title":"GraphBLASInterface.GrB_Col_extract","text":"GrB_Col_extract(w, mask, accum, A, I, ni, j, desc)\n\nExtract from one column of a matrix into a vector. With the transpose descriptor for the source matrix, elements of an arbitrary row of the matrix can be extracted with this function as well.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [1, 2, 2, 2, 3]; J = [1, 2, 1, 3, 3]; X = Int8[23, 34, 43, 57, 61]; n = 5;\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Matrix_fprint(MAT, GxB_COMPLETE)\n\nGraphBLAS matrix: MAT \nnrows: 4 ncols: 4 max # entries: 5\nformat: standard CSR vlen: 4 nvec_nonempty: 3 nvec: 4 plen: 4 vdim: 4\nhyper_ratio 0.0625\nGraphBLAS type:  int8_t size: 1\nnumber of entries: 5 \nrow: 1 : 1 entries [0:0]\n    column 1: int8 23\nrow: 2 : 3 entries [1:3]\n    column 1: int8 43\n    column 2: int8 34\n    column 3: int8 57\nrow: 3 : 1 entries [4:4]\n    column 3: int8 61\n\n\njulia> desc = GrB_Descriptor()\nGrB_Descriptor\n\njulia> GrB_Descriptor_new(desc)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Descriptor_set(desc, GrB_INP0, GrB_TRAN) # descriptor to transpose first input\nGrB_SUCCESS::GrB_Info = 0\n\njulia> out = GrB_Vector{Int8}()\nGrB_Vector{Int8}\n\njulia> GrB_Vector_new(out, GrB_INT8, 3)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Col_extract(out, GrB_NULL, GrB_NULL, MAT, [1, 2, 3], 3, 2, desc) # extract elements of row 2\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(out)[2]\n3-element Array{Int8,1}:\n 43\n 34\n 57\n\n\n\n\n\n","category":"function"},{"location":"operations/#Assign-1","page":"Operations","title":"Assign","text":"","category":"section"},{"location":"operations/#","page":"Operations","title":"Operations","text":"GrB_assign\nGrB_Vector_assign\nGrB_Matrix_assign\nGrB_Col_assign\nGrB_Row_assign","category":"page"},{"location":"operations/#GraphBLASInterface.GrB_assign","page":"Operations","title":"GraphBLASInterface.GrB_assign","text":"GrB_assign(arg1, Mask, accum, arg4, arg5, ...)\n\nGeneric method for submatrix/subvector assignment.\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Vector_assign","page":"Operations","title":"GraphBLASInterface.GrB_Vector_assign","text":"GrB_Vector_assign(w, mask, accum, u, I, ni, desc)\n\nAssign values from one GraphBLAS vector to a subset of a vector as specified by a set of indices. The size of the input vector is the same size as the index array provided.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(w, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 1]; X = [10, 20]; n = 2;\n\njulia> GrB_Vector_build(u, I, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_assign(w, GrB_NULL, GrB_NULL, u, [2, 4], 2, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(w)\n([2, 4], [10, 20])\n\n\n\n\n\nGrB_Vector_assign(w, mask, accum, x, I, ni, desc)\n\nAssign the same value to a specified subset of vector elements. With the use of GrB_ALL, the entire destination vector can be filled with the constant.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(w, GrB_FP64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_assign(w, GrB_NULL, GrB_NULL, 2.3, [0, 3], 2, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(w)\n([0, 3], [2.3, 2.3])\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Matrix_assign","page":"Operations","title":"GraphBLASInterface.GrB_Matrix_assign","text":"GrB_Matrix_assign(C, Mask, accum, A, I, ni, J, nj, desc)\n\nAssign values from one GraphBLAS matrix to a subset of a matrix as specified by a set of indices. The dimensions of the input matrix are the same size as the row and column index arrays provided.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 0, 2, 2]; J = [1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;\n\njulia> GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> C = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(C, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_assign(C, GrB_NULL, GrB_NULL, A, GrB_ALL, 4, GrB_ALL, 4, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractTuples(C)\n([0, 0, 2, 2], [1, 2, 0, 2], [10, 20, 30, 40])\n\n\n\n\n\nGrB_Matrix_assign(C, Mask, accum, x, I, ni, J, nj, desc)\n\nAssign the same value to a specified subset of matrix elements. With the use of GrB_ALL, the entire destination matrix can be filled with the constant.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Bool}()\nGrB_Matrix{Bool}\n\njulia> GrB_Matrix_new(A, GrB_BOOL, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_assign(A, GrB_NULL, GrB_NULL, true, [0, 1], 2, [0, 1], 2, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractTuples(A)\n([0, 0, 1, 1], [0, 1, 0, 1], Bool[true, true, true, true])\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Col_assign","page":"Operations","title":"GraphBLASInterface.GrB_Col_assign","text":"GrB_Col_assign(C, Mask, accum, u, I, ni, j, desc)\n\nAssign the contents of a vector to a subset of elements in one column of a matrix. Note that since the output cannot be transposed, a different variant of assign is provided to assign to a row of matrix.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 0, 2, 2]; J = [1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;\n\njulia> GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = [0, 1]; X2 = [5, 6]; n2 = 2;\n\njulia> GrB_Vector_build(u, I2, X2, n2, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Col_assign(A, GrB_NULL, GrB_NULL, u, [1, 2], 2, 0, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractTuples(A)\n([0, 0, 1, 2, 2], [1, 2, 0, 0, 2], [10, 20, 5, 6, 40])\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Row_assign","page":"Operations","title":"GraphBLASInterface.GrB_Row_assign","text":"GrB_Row_assign(C, mask, accum, u, i, J, nj, desc)\n\nAssign the contents of a vector to a subset of elements in one row of a matrix. Note that since the output cannot be transposed, a different variant of assign is provided to assign to a column of a matrix.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 0, 2, 2]; J = [1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;\n\njulia> GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = [0, 1]; X2 = [5, 6]; n2 = 2;\n\njulia> GrB_Vector_build(u, I2, X2, n2, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Row_assign(A, GrB_NULL, GrB_NULL, u, 0, [1, 3], 2, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractTuples(A)\n([0, 0, 0, 2, 2], [1, 2, 3, 0, 2], [5, 20, 6, 30, 40])\n\n\n\n\n\n","category":"function"},{"location":"operations/#Apply-1","page":"Operations","title":"Apply","text":"","category":"section"},{"location":"operations/#","page":"Operations","title":"Operations","text":"GrB_apply\nGrB_Vector_apply\nGrB_Matrix_apply","category":"page"},{"location":"operations/#GraphBLASInterface.GrB_apply","page":"Operations","title":"GraphBLASInterface.GrB_apply","text":"GrB_apply(C, Mask, accum, op, A, desc)\n\nGeneric matrix/vector apply.\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Vector_apply","page":"Operations","title":"GraphBLASInterface.GrB_Vector_apply","text":"GrB_Vector_apply(w, mask, accum, op, u, desc)\n\nCompute the transformation of the values of the elements of a vector using a unary function.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 3)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 2]; X = [10, 20]; n = 2;\n\njulia> GrB_Vector_build(u, I, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(w, GrB_INT64, 3)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_apply(w, GrB_NULL, GrB_NULL, GrB_AINV_INT64, u, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(w, GxB_COMPLETE)\n\nGraphBLAS vector: w \nnrows: 3 ncols: 1 max # entries: 2\nformat: standard CSC vlen: 3 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 2 \ncolumn: 0 : 2 entries [0:1]\n    row 0: int64 -10\n    row 2: int64 -20\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Matrix_apply","page":"Operations","title":"GraphBLASInterface.GrB_Matrix_apply","text":"GrB_Matrix_apply(C, Mask, accum, op, A, desc)\n\nCompute the transformation of the values of the elements of a matrix using a unary function.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 2, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 0, 1]; J = [0, 1, 1]; X = [10, 20, 30]; n = 3;\n\njulia> GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> B = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(B, GrB_INT64, 2, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_apply(B, GrB_NULL, GrB_NULL, GrB_AINV_INT64, A, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(B, GxB_COMPLETE)\n\nGraphBLAS matrix: B\nnrows: 2 ncols: 2 max # entries: 3\nformat: standard CSR vlen: 2 nvec_nonempty: 2 nvec: 2 plen: 2 vdim: 2\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 3\nrow: 0 : 2 entries [0:1]\n    column 0: int64 -10\n    column 1: int64 -20\nrow: 1 : 1 entries [2:2]\n    column 1: int64 -30\n\n\n\n\n\n","category":"function"},{"location":"operations/#Reduce-1","page":"Operations","title":"Reduce","text":"","category":"section"},{"location":"operations/#","page":"Operations","title":"Operations","text":"GrB_reduce\nGrB_Matrix_reduce_Monoid\nGrB_Matrix_reduce_BinaryOp\nGrB_Vector_reduce\nGrB_Matrix_reduce","category":"page"},{"location":"operations/#GraphBLASInterface.GrB_reduce","page":"Operations","title":"GraphBLASInterface.GrB_reduce","text":"GrB_reduce(arg1, arg2, arg3, arg4, ...)\n\nGeneric method for matrix/vector reduction to a vector or scalar.\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Matrix_reduce_Monoid","page":"Operations","title":"GraphBLASInterface.GrB_Matrix_reduce_Monoid","text":"GrB_Matrix_reduce_Monoid(w, mask, accum, monoid, A, desc)\n\nReduce the entries in a matrix to a vector. By default these methods compute a column vector w such that w(i) = sum(A(i,:)), where \"sum\" is a commutative and associative monoid with an identity value. A can be transposed, which reduces down the columns instead of the rows.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 0, 2, 2]; J = [1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;\n\njulia> GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(w, GrB_INT64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_reduce_Monoid(w, GrB_NULL, GrB_NULL, GxB_PLUS_INT64_MONOID, A, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(w, GxB_COMPLETE)\n\nGraphBLAS vector: w\nnrows: 4 ncols: 1 max # entries: 2\nformat: standard CSC vlen: 4 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 2\ncolumn: 0 : 2 entries [0:1]\n    row 0: int64 30\n    row 2: int64 70\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Matrix_reduce_BinaryOp","page":"Operations","title":"GraphBLASInterface.GrB_Matrix_reduce_BinaryOp","text":"GrB_Matrix_reduce_BinaryOp(w, mask, accum, op, A, desc)\n\nReduce the entries in a matrix to a vector. By default these methods compute a column vector w such that w(i) = sum(A(i,:)), where \"sum\" is a commutative and associative binary operator. A can be transposed, which reduces down the columns instead of the rows.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 0, 2, 2]; J = [1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;\n\njulia> GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(w, GrB_INT64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_reduce_BinaryOp(w, GrB_NULL, GrB_NULL, GrB_TIMES_INT64, A, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(w, GxB_COMPLETE)\n\nGraphBLAS vector: w\nnrows: 4 ncols: 1 max # entries: 2\nformat: standard CSC vlen: 4 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 2\ncolumn: 0 : 2 entries [0:1]\n    row 0: int64 200\n    row 2: int64 1200\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Vector_reduce","page":"Operations","title":"GraphBLASInterface.GrB_Vector_reduce","text":"GrB_Vector_reduce(monoid, u, desc)\n\nReduce entries in a vector to a scalar. All entries in the vector are \"summed\" using the reduce monoid, which must be associative (otherwise the results are undefined). If the vector has no entries, the result is the identity value of the monoid.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 2, 4]; X = [10, 20, 30]; n = 3;\n\njulia> GrB_Vector_build(u, I, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_reduce(GxB_MAX_INT64_MONOID, u, GrB_NULL)\n30\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Matrix_reduce","page":"Operations","title":"GraphBLASInterface.GrB_Matrix_reduce","text":"GrB_Matrix_reduce(monoid, A, desc)\n\nReduce entries in a matrix to a scalar. All entries in the matrix are \"summed\" using the reduce monoid, which must be associative (otherwise the results are undefined). If the matrix has no entries, the result is the identity value of the monoid.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 0, 2, 2]; J = [1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;\n\njulia> GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_reduce(GxB_MIN_INT64_MONOID, A, GrB_NULL)\n10\n\n\n\n\n\n","category":"function"},{"location":"operations/#Transpose-1","page":"Operations","title":"Transpose","text":"","category":"section"},{"location":"operations/#","page":"Operations","title":"Operations","text":"GrB_transpose","category":"page"},{"location":"operations/#GraphBLASInterface.GrB_transpose","page":"Operations","title":"GraphBLASInterface.GrB_transpose","text":"GrB_transpose(C, Mask, accum, A, desc)\n\nCompute a new matrix that is the transpose of the source matrix.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> M = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(M, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 0]; J = [1, 2]; X = [10, 20]; n = 2;\n\njulia> GrB_Matrix_build(M, I, J, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractTuples(M)\n([0, 0], [1, 2], [10, 20])\n\njulia> M_TRAN = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(M_TRAN, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_transpose(M_TRAN, GrB_NULL, GrB_NULL, M, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractTuples(M_TRAN)\n([1, 2], [0, 0], [10, 20])\n\n\n\n\n\n","category":"function"}]
}
